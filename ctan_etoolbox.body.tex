% vim: keymap=russian-jcukenwin
%%beginhead 
 
%%file body
%%parent 
 
%%endhead 

\printtitlepage
\tableofcontents

\section{introduction}
\label{int}

\subsection[about]{about \sty{etoolbox}}

the \sty{etoolbox} package is a toolbox of programming tools geared primarily towards \latex class and package authors. it provides \latex frontends to some of the new primitives provided by \etex as well as some generic tools which are not related to \etex but match the profile of this package.

\subsection{license}

copyright \textcopyright\ 2007--2011 philipp lehman, 2015--2020 joseph wright. permission is granted to copy, distribute and\slash or modify this software under the terms of the \lppl, version 1.3c or later.\fnurl{http://www.latex-project.org/lppl/}

\section{user commands}
\label{use}

the tools in this section are geared towards regular users as well as class and package authors.

\subsection{definitions}
\label{use:def}

\begin{ltxsyntax}

\cmditem{newrobustcmd}{command}[arguments][optarg default]{replacement text}
\cmditem*{newrobustcmd*}{command}[arguments][optarg default]{replacement text}

the syntax and behavior of this command is similar to \cmd{newcommand} except that the newly defined \prm{command} will be robust. the behavior of this command differs from the \cmd{declarerobustcommand} command from the \latex kernel in that it issues an error rather than just an informational message if the \prm{command} is already defined. since it uses \etex's low-level protection mechanism rather than the corresponding higher-level \latex facilities, it does not require an additional macro to implement the <robustness>.

\cmditem{renewrobustcmd}{command}[arguments][optarg default]{replacement text}
\cmditem*{renewrobustcmd*}{command}[arguments][optarg default]{replacement text}

the syntax and behavior of this command is similar to \cmd{renewcommand} except that the redefined \prm{command} will be robust.

\cmditem{providerobustcmd}{command}[arguments][optarg default]{replacement text}
\cmditem*{providerobustcmd*}{command}[arguments][optarg default]{replacement text}

the syntax and behavior of this command is similar to \cmd{providecommand} except that the newly defined \prm{command} will be robust. note that this command will provide a robust definition of the \prm{command} only if it is undefined. it will not make an already defined \prm{command} robust.

\end{ltxsyntax}

\subsection{patching}
\label{use:pat}

\begin{ltxsyntax}

\cmditem{robustify}{command}

redefines a \prm{command} defined with \cmd{newcommand} such that it is robust, without altering its parameters, its prefixes, or its replacement text. if the \prm{command} has been defined with \cmd{declarerobustcommand}, this will be detected automatically and \latex's high-level protection mechanism will be replaced by the corresponding low-level \etex feature.

\end{ltxsyntax}

\subsection{protection}
\label{use:pro}

\begin{ltxsyntax}

\cmditem{protecting}{code}

this command applies \latex's protection mechanism, which normally requires prefixing each fragile command with \cmd{protect}, to an entire chunk of arbitrary \prm{code}. its behavior depends on the current state of \cmd{protect}. note that the braces around the \prm{code} are mandatory even if it is a single token.

\end{ltxsyntax}

\subsection[lengths and counters]{length and counter assignments}
\label{use:cal}

the tools in this section are replacements for \cmd{setcounter} and \cmd{setlength} which support arithmetic expressions.

\begin{ltxsyntax}

\cmditem{defcounter}{counter}{integer expression}

assigns a value to a \latex \prm{counter} previously initialized with \cmd{newcounter}. this command is similar in concept and syntax to \cmd{setcounter} except for two major differences. 1) the second argument may be an \prm{integer expression} which will be processed with \cmd{numexpr}. the \prm{integer expression} may be any arbitrary code which is valid in this context. the value assigned to the \prm{counter} will be the result of that calculation. 2) in contrast to \cmd{setcounter}, the assignment is local by default but \cmd{defcounter} may be prefixed with \cs{global}. the functional equivalent of \cmd{setcounter} would be \cs{global}\cmd{defcounter}.

\cmditem{deflength}{length}{glue expression}

assigns a value to a \prm{length} register previously initialized with \cmd{newlength}. this command is similar in concept and syntax to \cmd{setlength} except that the second argument may be a \prm{glue expression} which will be processed with \cmd{glueexpr}. the \prm{glue expression} may be any arbitrary code which is valid in this context. the value assigned to the \prm{length} register will be the result of that calculation. the assignment is local by default but \cmd{deflength} may be prefixed with \cs{global}. this command may be used as a drop-in replacement for \cmd{setlength}.

\end{ltxsyntax}

\subsection[document hooks]{additional document hooks}
\label{use:pre}

\latex provides two hooks which defer the execution of code either to the beginning or to the end of the document body. any \cmd{atbegindocument} code is executed towards the beginning of the document body, after the main \file{aux} file has been read for the first time. any \cmd{atenddocument} code is executed at the end of the document body, before the main \file{aux} file is read for the second time. the hooks introduced here are similar in concept but defer the execution of their \prm{code} argument to slightly different locations. the \prm{code} may be arbitrary \tex code. parameter characters in the \prm{code} argument are permissible and need not be doubled.

\begin{ltxsyntax}

\cmditem{afterpreamble}{code}

this hook is a variant of \cmd{atbegindocument} which may be used in both the preamble and the document body. when used in the preamble, it behaves exactely like \cmd{atbegindocument}. when used in the document body, it immediately executes its \prm{code} argument. \cmd{atbegindocument} would issue an error in this case. this hook is useful to defer code which needs to write to the main \file{aux} file.

\cmditem{atendpreamble}{code}

this hook differs from \cmd{atbegindocument} in that the \prm{code} is executed right at the end of the preamble, before the main \file{aux} file (as written on the previous \latex pass) is read and prior to any \cmd{atbegindocument} code. note that it is not possible to write to the \file{aux} file at this point.

\cmditem{afterendpreamble}{code}

this hook differs from \cmd{atbegindocument} in that the \prm{code} is executed at the very end of |\begin{document}|, after any \cmd{atbegindocument} code. note that commands whose scope has been restricted to the preamble with \cmd{@onlypreamble} are no longer available when this hook is executed.

\cmditem{afterenddocument}{code}

this hook differs from \cmd{atenddocument} in that the \prm{code} is executed at the very end of the document, after the main \file{aux} file (as written on the current \latex pass) has been read and after any \cmd{atenddocument} code.

\end{ltxsyntax}

in a way, \cmd{atbegindocument} code is part neither of the preamble nor the document body but located in-between them since it gets executed in the middle of the initialization sequence performed prior to typesetting. it is sometimes desirable to move code to the end of the preamble because all requested packages have been loaded at this point. \cmd{atbegindocument} code, however, is executed too late if it is required in the \file{aux} file. in contrast to that, \cmd{atendpreamble} code is part of the preamble; \cmd{afterendpreamble} code is part of the document body and may contain printable text to be typeset at the very beginning of the document. to sum that up, \latex will perform the following tasks <inside> |\begin{document}|:

\begin{itemize}
\setlength{\itemsep}{0pt}
\item execute any \cmd{atendpreamble} code
\item start initialization for document body (page layout, default fonts, etc.)
\item load the main \file{aux} file written on the previous \latex pass
\item open the main \file{aux} file for writing on the current pass
\item continue initialization for document body
\item execute any \cmd{atbegindocument} code
\item complete initialization for document body
\item disable all \cmd{@onlypreamble} commands
\item execute any \cmd{afterendpreamble} code
\end{itemize}
%
inside |\end{document}|, \latex will perform the following tasks:

\begin{itemize}
\setlength{\itemsep}{0pt}
\item execute any \cmd{atenddocument} code
\item perform a final \cmd{clearpage} operation
\item close the main \file{aux} file for writing
\item load the main \file{aux} file written on the current \latex pass
\item perform final tests and issue warnings, if applicable
\item execute any \cmd{afterenddocument} code
\end{itemize}
%
any \cmd{atenddocument} code may be considered as being part of the document body insofar as it is still possible to perform typesetting tasks and write to the main \file{aux} file when it gets executed. \cmd{afterenddocument} code is not part of the document body. this hook is useful to evaluate the data in the \file{aux} file at the very end of a \latex pass.

\subsection[environment hooks]{environment hooks}
\label{use:env}

the tools in this section provide hooks for arbitrary environments. note that they will not modify the definition of the \prm{environment}. they hook into the \cmd{begin} and \cmd{end} commands instead. redefining the \prm{environment} will not clear the corresponding hooks. the \prm{code} may be arbitrary \tex code. parameter characters in the \prm{code} argument are permissible and need not be doubled.

\begin{ltxsyntax}

\cmditem{atbeginenvironment}{environment}{code}

appends arbitrary \prm{code} to a hook executed by the \cmd{begin} command at the beginning of a given \prm{environment}, immediately before \cmd{\prm{environment}}, inside the group opened by \cmd{begin}.

\cmditem{atendenvironment}{environment}{code}

appends arbitrary \prm{code} to a hook executed by the \cmd{end} command at the end of a given \prm{environment}, immediately before \cmd{end\prm{environment}}, inside the group opened by \cmd{begin}.

\cmditem{beforebeginenvironment}{environment}{code}

appends arbitrary \prm{code} to a hook executed at a very early point by the \cmd{begin} command, before the group holding the environment is opened.

\cmditem{afterendenvironment}{environment}{code}

appends arbitrary \prm{code} to a hook executed at a very late point by the \cmd{end} command, after the group holding the environment has been closed.

\end{ltxsyntax}

\section{author commands}

the tools in this section are geared towards class and package authors.

\subsection{definitions}

\subsubsection{macro definitions}
\label{aut:def:def}

the tools in this section are simple but frequently required shorthands which extend the scope of the \cmd{@namedef} and \cmd{@nameuse} macros from the \latex kernel.

\begin{ltxsyntax}

\cmditem{csdef}{csname}<arguments>{replacement text}

similar to the \tex primitive \cmd{def} except that it takes a control sequence name as its first argument. this command is robust and corresponds to \cmd{@namedef}.

\cmditem{csgdef}{csname}<arguments>{replacement text}

similar to the \tex primitive \cmd{gdef} except that it takes a control sequence name as its first argument. this command is robust.

\cmditem{csedef}{csname}<arguments>{replacement text}

similar to the \tex primitive \cmd{edef} except that it takes a control sequence name as its first argument. this command is robust.

\cmditem{csxdef}{csname}<arguments>{replacement text}

similar to the \tex primitive \cmd{xdef} except that it takes a control sequence name as its first argument. this command is robust.

\cmditem{protected@csedef}{csname}<arguments>{replacement text}

similar to \cmd{csedef} except that \latex's protection mechanism is temporarily enabled. to put it in other words: this command is similar to the \latex kernel command \cmd{protected@edef} except that it takes a control sequence name as its first argument. this command is robust.

\cmditem{protected@csxdef}{csname}<arguments>{replacement text}

similar to \cmd{csxdef} except that \latex's protection mechanism is temporarily enabled. to put it in other words: this command is similar to the \latex kernel command \cmd{protected@xdef} except that it takes a control sequence name as its first argument. this command is robust.

\cmditem{cslet}{csname}{command}

similar to the \tex primitive \cmd{let} except that the first argument is a control sequence name. if \prm{command} is undefined, \prm{csname} will be undefined as well after the assignment. this command is robust and may be prefixed with \cs{global}.

\cmditem{letcs}{command}{csname}

similar to the \tex primitive \cmd{let} except that the second argument is a control sequence name. if \prm{csname} is undefined, the \prm{command} will be undefined as well after the assignment. this command is robust and may be prefixed with \cs{global}.

\cmditem{csletcs}{csname}{csname}

similar to the \tex primitive \cmd{let} except that both arguments are control sequence names. if the second \prm{csname} is undefined, the first \prm{csname} will be undefined as well after the assignment. this command is robust and may be prefixed with \cs{global}.

\cmditem{csuse}{csname}

takes a control sequence name as its argument and forms a control sequence token. this command differs from the \cmd{@nameuse} macro in the \latex kernel in that it expands to an empty string if the control sequence is undefined.

\cmditem{undef}<command>

clears a \prm{command} such that \etex's \cmd{ifdefined} and \cmd{ifcsname} tests will consider it as undefined. this command is robust and may be prefixed with \cs{global}.

\cmditem{gundef}<command>

similar to \cmd{undef} but acts globally.

\cmditem{csundef}{csname}

similar to \cmd{undef} except that it takes a control sequence name as its argument. this command is robust and may be prefixed with \cs{global}.

\cmditem{csgundef}{csname}

similar to \cmd{csundef} but acts globally.

\cmditem{csmeaning}{csname}

similar to the \tex primitive \cmd{meaning} but takes a control sequence name as its argument. if the control sequence is undefined, this command will not implicitly assign a meaning of \cmd{relax} to it.

\cmditem{csshow}{csname}

similar to the \tex primitive \cmd{show} but takes a control sequence name as its argument. if the control sequence is undefined, this command will not implicitly assign a meaning of \cmd{relax} to it. this command is robust.

\end{ltxsyntax}

\subsubsection{arithmetic definitions}
\label{aut:def:cal}

the tools in this section permit calculations using macros rather than length registers and counters.

\begin{ltxsyntax}

\cmditem{numdef}<command>{integer expression}

similar to \cmd{edef} except that the \prm{integer expression} is processed with \cmd{numexpr}. the \prm{integer expression} may be any arbitrary code which is valid in this context. the replacement text assigned to the \prm{command} will be the result of that calculation. if the \prm{command} is undefined, it will be initialized to \texttt{0} before the \prm{integer expression} is processed.

\cmditem{numgdef}<command>{integer expression}

similar to \cmd{numdef} except that the assignment is global.

\cmditem{csnumdef}{csname}{integer expression}

similar to \cmd{numdef} except that it takes a control sequence name as its first argument.

\cmditem{csnumgdef}{csname}{integer expression}

similar to \cmd{numgdef} except that it takes a control sequence name as its first argument.

\cmditem{dimdef}<command>{dimen expression}

similar to \cmd{edef} except that the \prm{dimen expression} is processed with \cmd{dimexpr}. the \prm{dimen expression} may be any arbitrary code which is valid in this context. the replacement text assigned to the \prm{command} will be the result of that calculation. if the \prm{command} is undefined, it will be initialized to \texttt{0pt} before the \prm{dimen expression} is processed.

\cmditem{dimgdef}<command>{dimen expression}

similar to \cmd{dimdef} except that the assignment is global.

\cmditem{csdimdef}{csname}{dimen expression}

similar to \cmd{dimdef} except that it takes a control sequence name as its first argument.

\cmditem{csdimgdef}{csname}{dimen expression}

similar to \cmd{dimgdef} except that it takes a control sequence name as its first argument.

\cmditem{gluedef}<command>{glue expression}

similar to \cmd{edef} except that the \prm{glue expression} is processed with \cmd{glueexpr}. the \prm{glue expression} may be any arbitrary code which is valid in this context. the replacement text assigned to the \prm{command} will be the result of that calculation. if the \prm{command} is undefined, it will be initialized to \texttt{0pt plus 0pt minus 0pt} before the \prm{glue expression} is processed.

\cmditem{gluegdef}<command>{glue expression}

similar to \cmd{gluedef} except that the assignment is global.

\cmditem{csgluedef}{csname}{glue expression}

similar to \cmd{gluedef} except that it takes a control sequence name as its first argument.

\cmditem{csgluegdef}{csname}{glue expression}

similar to \cmd{gluegdef} except that it takes a control sequence name as its first argument.

\cmditem{mudef}<command>{muglue expression}

similar to \cmd{edef} except that the \prm{muglue expression} is processed with \cmd{muexpr}. the \prm{muglue expression} may be any arbitrary code which is valid in this context. the replacement text assigned to the \prm{command} will be the result of that calculation. if the \prm{command} is undefined, it will be initialized to \texttt{0mu} before the \prm{muglue expression} is processed.

\cmditem{mugdef}<command>{muglue expression}

similar to \cmd{mudef} except that the assignment is global.

\cmditem{csmudef}{csname}{muglue expression}

similar to \cmd{mudef} except that it takes a control sequence name as its first argument.

\cmditem{csmugdef}{csname}{muglue expression}

similar to \cmd{mugdef} except that it takes a control sequence name as its first argument.

\end{ltxsyntax}

\subsection{expansion control}
\label{aut:exp}

the tools in this section are useful to control expansion in an \cmd{edef} or a similar context.

\begin{ltxsyntax}

\cmditem{expandonce}<command>

this command expands a \prm{command} once and prevents further expansion of the replacement text. this command is expandable.

\cmditem{csexpandonce}{csname}

similar to \cmd{expandonce} except that it takes a control sequence name as its argument.

\end{ltxsyntax}

\subsection{hook management}
\label{aut:hok}

the tools in this section are intended for hook management. a \prm{hook} in this context is a plain macro without any parameters and prefixes which is used to collect code to be executed later. these tools may also be useful to patch simple macros by appending code to their replacement text. for more complex patching operations, see section \ref{aut:pat}. all commands in this section will initialize the \prm{hook} if it is undefined.

\subsubsection{appending to a hook}
\label{aut:hok:app}

the tools in this section append arbitrary code to a hook.

\begin{ltxsyntax}

\cmditem{appto}<hook>{code}

this command appends arbitrary \prm{code} to a \prm{hook}. if the \prm{code} contains any parameter characters, they need not be doubled. this command is robust.

\cmditem{gappto}<hook>{code}

similar to \cmd{appto} except that the assignment is global. this command may be used as a drop-in replacement for the \cmd{g@addto@macro} command in the \latex kernel.

\cmditem{eappto}<hook>{code}

this command appends arbitrary \prm{code} to a \prm{hook}. the \prm{code} is expanded at definition"=time. only the new \prm{code} is expanded, the current replacement text of the \prm{hook} is not. this command is robust.

\cmditem{xappto}<hook>{code}

similar to \cmd{eappto} except that the assignment is global.

\cmditem{protected@eappto}<hook>{code}

similar to \cmd{eappto} except that \latex's protection mechanism is temporarily enabled.

\cmditem{protected@xappto}<hook>{code}

similar to \cmd{xappto} except that \latex's protection mechanism is temporarily enabled.

\cmditem{csappto}{csname}{code}

similar to \cmd{appto} except that it takes a control sequence name as its first argument.

\cmditem{csgappto}{csname}{code}

similar to \cmd{gappto} except that it takes a control sequence name as its first argument.

\cmditem{cseappto}{csname}{code}

similar to \cmd{eappto} except that it takes a control sequence name as its first argument.

\cmditem{csxappto}{csname}{code}

similar to \cmd{xappto} except that it takes a control sequence name as its first argument.

\cmditem{protected@cseappto}<hook>{code}

similar to \cmd{protected@eappto} except that it takes a control sequence name as its first argument.

\cmditem{protected@csxappto}<hook>{code}

similar to \cmd{protected@xappto} except that it takes a control sequence name as its first argument.

\end{ltxsyntax}

\subsubsection{prepending to a hook}
\label{aut:hok:pre}

the tools in this section <prepend> arbitrary code to a hook, \ie the code is inserted at the beginning of the hook rather than being added at the end.

\begin{ltxsyntax}

\cmditem{preto}<hook>{code}

similar to \cmd{appto} except that the \prm{code} is prepended.

\cmditem{gpreto}<hook>{code}

similar to \cmd{preto} except that the assignment is global.

\cmditem{epreto}<hook>{code}

similar to \cmd{eappto} except that the \prm{code} is prepended.

\cmditem{xpreto}<hook>{code}

similar to \cmd{epreto} except that the assignment is global.

\cmditem{protected@epreto}<hook>{code}

similar to \cmd{epreto} except that \latex's protection mechanism is temporarily enabled.

\cmditem{protected@xpreto}<hook>{code}

similar to \cmd{xpreto} except that \latex's protection mechanism is temporarily enabled.

\cmditem{cspreto}{csname}{code}

similar to \cmd{preto} except that it takes a control sequence name as its first argument.

\cmditem{csgpreto}{csname}{code}

similar to \cmd{gpreto} except that it takes a control sequence name as its first argument.

\cmditem{csepreto}{csname}{code}

similar to \cmd{epreto} except that it takes a control sequence name as its first argument.

\cmditem{csxpreto}{csname}{code}

similar to \cmd{xpreto} except that it takes a control sequence name as its first argument.

\cmditem{protected@csepreto}<hook>{code}

similar to \cmd{protected@epreto} except that it takes a control sequence name as its first argument.

\cmditem{protected@csxpreto}<hook>{code}

similar to \cmd{protected@xpreto} except that it takes a control sequence name as its first argument.

\end{ltxsyntax}

\subsection{patching}
\label{aut:pat}

the tools in this section are useful to hook into or modify existing code. all commands presented here preserve the parameters and the prefixes of the patched \prm{command}. note that \cs{outer} commands may not be patched. also note that the commands in this section will not automatically issue any error messages if patching fails. instead, they take a \prm{failure} argument which should provide suitable fallback code or an error message. issuing \cmd{tracingpatches} in the preamble will cause the commands to write debugging information to the transcript file.

\begin{ltxsyntax}

\cmditem{patchcmd}[prefix]{command}{search}{replace}{success}{failure}

this command extracts the replacement text of a \prm{command}, replaces \prm{search} with \prm{replace}, and reassembles the \prm{command}. the pattern match is category code agnostic and matches the first occurence of the \prm{search} pattern in the replacement text of the \prm{command} to be patched. note that the patching process involves detokenizing the replacement text of the \prm{command} and retokenizing it under the current category code regime after patching. the category code of the @ sign is temporarily set to 11. if the replacement text of the \prm{command} includes any tokens with non"=standard category codes, the respective category codes must be adjusted prior to patching. if the code to be replaced or inserted refers to the parameters of the \prm{command} to be patched, the parameter characters need not be doubled. if an optional \prm{prefix} is specified, it replaces the prefixes of the \prm{command}. an empty \prm{prefix} argument strips all prefixes from the \prm{command}. the assignment is local. this command implicitly performs the equivalent of an \cmd{ifpatchable} test prior to patching. if this test succeeds, the command applies the patch and executes \prm{success}. if the test fails, it executes \prm{failure} without modifying the original \prm{command}. this command is robust.

\cmditem{ifpatchable}{command}{search}{true}{false}

this command executes \prm{true} if the \prm{command} may be patched with \cmd{patchcmd} and if the \prm{search} pattern is found in its replacement text, and \prm{false} otherwise. this command is robust.

\cmditem*{ifpatchable*}{command}{true}{false}

similar to \cmd{ifpatchable} except that the starred variant does not require a search pattern. use this version to check if a command may be patched with \cmd{apptocmd} and \cmd{pretocmd}.

\cmditem{apptocmd}{command}{code}{success}{failure}

this command appends \prm{code} to the replacement text of a \prm{command}. if the \prm{command} is a parameterless macro, it behaves like \cmd{appto} from section \ref{aut:hok:app}. in contrast to \cmd{appto}, \cmd{apptocmd} may also be used to patch commands with parameters. in this case, it will detokenize the replacement text of the \prm{command}, apply the patch, and retokenize it under the current category code regime. the category code of the @ sign is temporarily set to 11. the \prm{code} may refer to the parameters of the \prm{command}. the assignment is local. if patching succeeds, this command executes \prm{success}. if patching fails, it executes \prm{failure} without modifying the original \prm{command}. this command is robust.

\cmditem{pretocmd}{command}{code}{success}{failure}

this command is similar to \cmd{apptocmd} except that the \prm{code} is inserted at the beginning of the replacement text of the \prm{command}. if the \prm{command} is a parameterless macro, it behaves like \cmd{preto} from section \ref{aut:hok:app}. in contrast to \cmd{preto}, \cmd{pretocmd} may also be used to patch commands with parameters. in this case, it will detokenize the replacement text of the \prm{command}, apply the patch, and retokenize it under the current category code regime. the category code of the @ sign is temporarily set to 11. the \prm{code} may refer to the parameters of the \prm{command}. the assignment is local. if patching succeeds, this command executes \prm{success}. if patching fails, it executes \prm{failure} without modifying the original \prm{command}. this command is robust.

\csitem{tracingpatches}

enables tracing for all patching commands, including \cmd{ifpatchable}. the debugging information will be written to the transcript file. this is useful if the reason why a patch is not applied or \cmd{ifpatchable} yields \prm{false} is not obvious. this command must be issued in the preamble.

\end{ltxsyntax}

\subsection{boolean flags}
\label{aut:bol}

this package provides two interfaces to boolean flags which are completely independent of each other. the tools in section \ref{aut:bo1:bol} are a \latex frontend to \cmd{newif}. those in section \ref{aut:bo1:tgl} use a different mechanism.

\subsubsection{\tex flags}
\label{aut:bo1:bol}

since the tools in this section are based on \cmd{newif} internally, they may be used to test and alter the state of flags previously defined with \cmd{newif}. they are also compatible with the boolean tests of the \sty{ifthen} package and may serve as a \latex interface for querying \tex primitives such as \cmd{ifmmode}. the \cmd{newif} approach requires a total of three macros per flag.

\begin{ltxsyntax}

\cmditem{newbool}{name}

defines a new boolean flag called \prm{name}. if the flag has already been defined, this command issues an error. the initial state of newly defined flags is \texttt{false}. this command is robust.

\cmditem{providebool}{name}

defines a new boolean flag called \prm{name} unless it has already been defined. this command is robust.

\cmditem{booltrue}{name}

sets the boolean flag \prm{name} to \texttt{true}. this command is robust and may be prefixed with \cs{global}. it will issue an error if the flag is undefined.

\cmditem{boolfalse}{name}

sets the boolean flag \prm{name} to \texttt{false}. this command is robust and may be prefixed with \cs{global}. it will issue an error if the flag is undefined.

\cmditem{setbool}{name}{value}

sets the boolean flag \prm{name} to \prm{value} which may be either \texttt{true} or \texttt{false}. this command is robust and may be prefixed with \cs{global}. it will issue an error if the flag is undefined.

\cmditem{ifbool}{name}{true}{false}

expands to \prm{true} if the state of the boolean flag \prm{name} is \texttt{true}, and to \prm{false} otherwise. if the flag is undefined, this command issues an error. this command may be used to perform any boolean test based on plain \tex syntax, \ie any test normally employed like this:

\begin{ltxcode}
<<\iftest>> true<<\else>> false<<\fi>>
\end{ltxcode}

this includes all flags defined with \cmd{newif} as well as \tex primitives such as \cmd{ifmmode}. the \cmd{if} prefix is omitted when using the flag or the primitive in the expression. for example:

\begin{ltxcode}
<<\ifmytest>> true\else false\fi
<<\ifmmode>> true\else false\fi
\end{ltxcode}
%
becomes

\begin{ltxcode}
\ifbool{<<mytest>>}{true}{false}
\ifbool{<<mmode>>}{true}{false}
\end{ltxcode}

\cmditem{notbool}{name}{not true}{not false}

similar to \cmd{ifbool} but negates the test.

\end{ltxsyntax}

\subsubsection{\latex flags}
\label{aut:bo1:tgl}

in contrast to the flags from section \ref{aut:bo1:bol}, the tools in this section require only one macro per flag. they also use a separate namespace to avoid name clashes with regular macros.

\begin{ltxsyntax}

\cmditem{newtoggle}{name}

defines a new boolean flag called \prm{name}. if the flag has already been defined, this command issues an error. the initial state of newly defined flags is \texttt{false}. this command is robust.

\cmditem{providetoggle}{name}

defines a new boolean flag called \prm{name} unless it has already been defined. this command is robust.

\cmditem{toggletrue}{name}

sets the boolean flag \prm{name} to \texttt{true}. this command is robust and may be prefixed with \cs{global}. it will issue an error if the flag is undefined.

\cmditem{togglefalse}{name}

sets the boolean flag \prm{name} to \texttt{false}. this command is robust and may be prefixed with \cs{global}. it will issue an error if the flag is undefined.

\cmditem{settoggle}{name}{value}

sets the boolean flag \prm{name} to \prm{value} which may be either \texttt{true} or \texttt{false}. this command is robust and may be prefixed with \cs{global}. it will issue an error if the flag is undefined.

\cmditem{iftoggle}{name}{true}{false}

expands to \prm{true} if the state of the boolean flag \prm{name} is \texttt{true}, and to \prm{false} otherwise. if the flag is undefined, this command issues an error.

\cmditem{nottoggle}{name}{not true}{not false}

similar to \cmd{iftoggle} but negates the test.

\end{ltxsyntax}

\subsection{generic tests}
\label{aut:tst}

\subsubsection{macro tests}
\label{aut:tst:def}

\begin{ltxsyntax}

\cmditem{ifdef}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is defined, and to \prm{false} otherwise. note that control sequences will be considered as defined even if their meaning is \cmd{relax}. this command is a \latex wrapper for the \etex primitive \cmd{ifdefined}.

\cmditem{ifcsdef}{csname}{true}{false}

similar to \cmd{ifdef} except that it takes a control sequence name as its first argument. this command is a \latex wrapper for the \etex primitive \cmd{ifcsname}.

\cmditem{ifundef}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is undefined, and to \prm{false} otherwise. apart from reversing the logic of the test, this command also differs from \cmd{ifdef} in that commands will be considered as undefined if their meaning is \cmd{relax}.

\cmditem{ifcsundef}{csname}{true}{false}

similar to \cmd{ifundef} except that it takes a control sequence name as its first argument. this command may be used as a drop-in replacement for the \cmd{@ifundefined} test in the \latex kernel.

\cmditem{ifdefmacro}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is defined and is a macro, and to \prm{false} otherwise.

\cmditem{ifcsmacro}{csname}{true}{false}

similar to \cmd{ifdefmacro} except that it takes a control sequence name as its first argument.

\cmditem{ifdefparam}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is defined and is a macro with one or more parameters, and to \prm{false} otherwise.

\cmditem{ifcsparam}{csname}{true}{false}

similar to \cmd{ifdefparam} except that it takes a control sequence name as its first argument.

\cmditem{ifdefprefix}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is defined and is a macro prefixed with \cs{long} and\slash or \cs{protected}, and to \prm{false} otherwise. note that \cs{outer} macros may not be tested.

\cmditem{ifcsprefix}{csname}{true}{false}

similar to \cmd{ifdefprefix} except that it takes a control sequence name as its first argument.

\cmditem{ifdefprotected}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is defined and is a macro prefixed with \cs{protected}, and to \prm{false} otherwise.

\cmditem{ifcsprotected}{csname}{true}{false}

similar to \cmd{ifdefprotected} except that it takes a control sequence name as its first argument.

\cmditem{ifdefltxprotect}{control sequence}{true}{false}

executes \prm{true} if the \prm{control sequence} is defined and is a \latex protection shell, and \prm{false} otherwise. this command is robust. it will detect commands which have been defined with \cmd{declarerobustcommand} or by way of a similar technique.

\cmditem{ifcsltxprotect}{csname}{true}{false}

similar to \cmd{ifdefltxprotect} except that it takes a control sequence name as its first argument.

\cmditem{ifdefempty}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is defined and is a parameterless macro whose replacement text is empty, and to \prm{false} otherwise. in contrast to \cmd{ifx}, this test ignores the prefixes of the \prm{command}.

\cmditem{ifcsempty}{csname}{true}{false}

similar to \cmd{ifdefempty} except that it takes a control sequence name as its first argument.

\cmditem{ifdefvoid}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is undefined, or is a control sequence whose meaning is \cmd{relax}, or is  a parameterless macro whose replacement text is empty, and to \prm{false} otherwise.

\cmditem{ifcsvoid}{csname}{true}{false}

similar to \cmd{ifdefvoid} except that it takes a control sequence name as its first argument.

\cmditem{ifdefequal}{control sequence}{control sequence}{true}{false}

compares two control sequences and expands to \prm{true} if they are equal in the sense of \cmd{ifx}, and to \prm{false} otherwise. in contrast to \cmd{ifx}, this test will also yield \prm{false} if both control sequences are undefined or have a meaning of \cmd{relax}.

\cmditem{ifcsequal}{csname}{csname}{true}{false}

similar to \cmd{ifdefequal} except that it takes control sequence names as arguments.

\cmditem{ifdefstring}{command}{string}{true}{false}

compares the replacement text of a \prm{command} to a \prm{string} and executes \prm{true} if they are equal, and \prm{false} otherwise. neither the \prm{command} nor the \prm{string} is expanded in the test and the comparison is category code agnostic. control sequence tokens in the \prm{string} argument will be detokenized and treated as strings. this command is robust. note that it will only consider the replacement text of the \prm{command}. for example, this test

\begin{ltxcode}
\long\edef\mymacro#1#2{\string&}
\ifdefstring{\mymacro}{&}{true}{false}
\end{ltxcode}
%
would yield \prm{true}. the prefix and the parameters of \cmd{mymacro} as well as the category codes in the replacement text are ignored.

\cmditem{ifcsstring}{csname}{string}{true}{false}

similar to \cmd{ifdefstring} except that it takes a control sequence name as its first argument.

\cmditem{ifdefstrequal}{command}{command}{true}{false}

performs a category code agnostic string comparison of the replacement text of two commands. this command is similar to \cmd{ifdefstring} except that both arguments to be compared are macros. this command is robust.

\cmditem{ifcsstrequal}{csname}{csname}{true}{false}

similar to \cmd{ifdefstrequal} except that it takes control sequence names as arguments.

\end{ltxsyntax}

\subsubsection{counter and length tests}
\label{aut:tst:cnt}

\begin{ltxsyntax}

\cmditem{ifdefcounter}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is a \tex \cmd{count} register allocated with \cmd{newcount}, and to \prm{false} otherwise.

\cmditem{ifcscounter}{csname}{true}{false}

similar to \cmd{ifdefcounter} except that it takes a control sequence name as its first argument.

\cmditem{ifltxcounter}{name}{true}{false}

expands to \prm{true} if \prm{name} is a \latex counter allocated with \cmd{newcounter}, and to \prm{false} otherwise.

\cmditem{ifdeflength}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is a \tex \cmd{skip} register allocated with \cmd{newskip} or \cmd{newlength}, and to \prm{false} otherwise.

\cmditem{ifcslength}{csname}{true}{false}

similar to \cmd{ifdeflength} except that it takes a control sequence name as its first argument.

\cmditem{ifdefdimen}{control sequence}{true}{false}

expands to \prm{true} if the \prm{control sequence} is a \tex \cmd{dimen} register allocated with \cmd{newdimen}, and to \prm{false} otherwise.

\cmditem{ifcsdimen}{csname}{true}{false}

similar to \cmd{ifdefdimen} except that it takes a control sequence name as its first argument.

\end{ltxsyntax}

\subsubsection{string tests}
\label{aut:tst:str}

\begin{ltxsyntax}

\cmditem{ifstrequal}{string}{string}{true}{false}

compares two strings and executes \prm{true} if they are equal, and \prm{false} otherwise. the strings are not expanded in the test and the comparison is category code agnostic. control sequence tokens in any of the \prm{string} arguments will be detokenized and treated as strings. this command is robust.

\cmditem{ifstrempty}{string}{true}{false}

expands to \prm{true} if the \prm{string} is empty, and to \prm{false} otherwise. the \prm{string} is not expanded in the test.

\cmditem{ifblank}{string}{true}{false}

expands to \prm{true} if the \prm{string} is blank (empty or spaces), and to \prm{false} otherwise. the \prm{string} is not expanded in the test.

\cmditem{notblank}{string}{not true}{not false}

similar to \cmd{ifblank} but negates the test.

\end{ltxsyntax}

\subsubsection{arithmetic tests}
\label{aut:tst:num}

\begin{ltxsyntax}

\cmditem{ifnumcomp}{integer expression}{relation}{integer expression}{true}{false}

compares two integer expressions according to \prm{relation} and expands to \prm{true} or \prm{false} depending on the result. the \prm{relation} may be |<|, |>|, or |=|. both integer expressions will be processed with \cmd{numexpr}. an \prm{integer expression} may be any arbitrary code which is valid in this context. all arithmetic expressions may contain spaces. here are some examples:

\begin{ltxcode}
\ifnumcomp{<<3>>}{<<>>>}{<<6>>}{true}{<<false>>}
\ifnumcomp{<<(7 + 5) / 2>>}{<<=>>}{<<6>>}{<<true>>}{false}
\ifnumcomp{<<(7+5) / 4>>}{<<>>>}{<<3*(12-10)>>}{true}{<<false>>}
\newcounter{counta}
\setcounter{counta}{<<6>>}
\newcounter{countb}
\setcounter{countb}{<<5>>}
\ifnumcomp{<<\value{counta} * \value{countb}/2}>>{<<=>>}{<<15>>}{<<true>>}{false}
\ifnumcomp{<<6/2>>}{<<=>>}{<<5/2>>}{<<true>>}{false}
\end{ltxcode}
%
technically, this command is a \latex wrapper for the \tex primitive \cmd{ifnum}, incorporating \cmd{numexpr}. note that \cmd{numexpr} will round the result of all integer expressions, \ie both expressions will be processed and rounded prior to being compared. in the last line of the above examples, the result of the second expression is 2.5, which is rounded to 3, hence \cmd{ifnumcomp} will expand to \prm{true}.

\cmditem{ifnumequal}{integer expression}{integer expression}{true}{false}

alternative syntax for |\ifnumcomp{...}{=}{...}{...}{...}|.

\cmditem{ifnumgreater}{integer expression}{integer expression}{true}{false}

alternative syntax for |\ifnumcomp{...}{>}{...}{...}{...}|.

\cmditem{ifnumless}{integer expression}{integer expression}{true}{false}

alternative syntax for |\ifnumcomp{...}{<}{...}{...}{...}|.

\cmditem{ifnumodd}{integer expression}{true}{false}

evaluates an integer expression and expands to \prm{true} if the result is an odd number, and to \prm{false} otherwise. technically, this command is a \latex wrapper for the \tex primitive \cmd{ifodd}, incorporating \cmd{numexpr}.

\cmditem{ifdimcomp}{dimen expression}{relation}{dimen expression}{true}{false}

compares two dimen expressions according to \prm{relation} and expands to \prm{true} or \prm{false} depending on the result. the \prm{relation} may be |<|, |>|, or |=|. both dimen expressions will be processed with \cmd{dimexpr}. a \prm{dimen expression} may be any arbitrary code which is valid in this context. all arithmetic expressions may contain spaces. here are some examples:

\begin{ltxcode}
\ifdimcomp{<<1cm>>}{<<=>>}{<<28.45274pt>>}{<<true>>}{false}
\ifdimcomp{<<(7pt + 5pt) / 2>>}{<<<>>}{2pt}{true}{<<false>>}
\ifdimcomp{<<(3.725pt + 0.025pt) * 2>>}{<<<>>}{<<7pt>>}{true}{<<false>>}
\newlength{\lengtha}
\setlength{\lengtha}{<<7.25pt>>}
\newlength{\lengthb}
\setlength{\lengthb}{<<4.75pt>>}
\ifdimcomp{<<(\lengtha + \lengthb) / 2>>}{<<>>>}{<<2.75pt * 2>>}{<<true>>}{false}
\ifdimcomp{<<(\lengtha + \lengthb) / 2>>}{<<>>>}{<<25pt / 6>>}{<<true>>}{false}
\end{ltxcode}
%
technically, this command is a \latex wrapper for the \tex primitive \cmd{ifdim}, incorporating \cmd{dimexpr}. since both \cmd{ifdimcomp} and \cmd{ifnumcomp} are expandable, they may also be nested:

\begin{ltxcode}
<<\ifnumcomp>>{<<\ifdimcomp>>{<<5pt+5pt>>}{<<=>>}{<<10pt>>}{<<1>>}{<<0>>}}{<<>>>}{<<0>>}{<<true>>}{false}
\end{ltxcode}

\cmditem{ifdimequal}{dimen expression}{dimen expression}{true}{false}

alternative syntax for |\ifdimcomp{...}{=}{...}{...}{...}|.

\cmditem{ifdimgreater}{dimen expression}{dimen expression}{true}{false}

alternative syntax for |\ifdimcomp{...}{>}{...}{...}{...}|.

\cmditem{ifdimless}{dimen expression}{dimen expression}{true}{false}

alternative syntax for |\ifdimcomp{...}{<}{...}{...}{...}|.

\end{ltxsyntax}

\subsubsection{boolean expressions}
\label{aut:tst:bol}

the commands in this section are replacements for the \cmd{ifthenelse} command provided by the \sty{ifthen} package. they serve the same purpose but differ in syntax, concept, and implementation. in contrast to \cmd{ifthenelse}, they do not provide any tests of their own but serve as a frontend to other tests. any test which satisfies certain syntactical requirements may be used in a boolean expression.

\begin{ltxsyntax}

\cmditem{ifboolexpr}{expression}{true}{false}

evaluates the \prm{expression} and executes \prm{true} if it is true, and \prm{false} otherwise. the \prm{expression} is evaluated sequentially from left to right. the following elements, discussed in more detail below, are available in the \prm{expression}: the test operators \texttt{togl}, \texttt{bool}, \texttt{test}; the logical operators \texttt{not}, \texttt{and}, \texttt{or}; and the subexpression delimiter \texttt{(...)}. spaces, tabs, and line endings may be used freely to arrange the \prm{expression} visually. blank lines are not permissible in the \prm{expression}. this command is robust.

\cmditem{ifboolexpe}{expression}{true}{false}

an expandable version of \cmd{ifboolexpr} which may be processed in an expansion-only context, \eg in an \cmd{edef} or in a \cmd{write} operation. note that all tests used in the \prm{expression} must be expandable, even if \cmd{ifboolexpe} is not located in an expansion-only context.

\cmditem{whileboolexpr}{expression}{code}

evaluates the \prm{expression} like \cmd{ifboolexpr} and repeatedly executes the \prm{code} while the expression is true. the \prm{code} may be any valid \tex or \latex code. this command is robust.

\cmditem{unlessboolexpr}{expression}{code}

similar to \cmd{whileboolexpr} but negates the \prm{expression}, \ie it keeps executing the \prm{code} repeatedly unless the expression is true. this command is robust.

\end{ltxsyntax}
%
the following test operators are available in the \prm{expression}:

\begin{marglist}
\appto\marglistfont{\verbatimfont}

\item[togl]

use the \texttt{togl} operator to test the state of a flag defined with \cmd{newtoggle}. for example:

\begin{ltxcode}
<<\iftoggle{mytoggle}>>{true}{false}
\end{ltxcode}
%
becomes

\begin{ltxcode}
\ifboolexpr{ <<togl>> {<<mytoggle>>} }{true}{false}
\end{ltxcode}
%
the \texttt{togl} operator may be used with both \cmd{ifboolexpr} and \cmd{ifboolexpe}.

\item[bool]

use the \texttt{bool} operator to perform a boolean test based on plain \tex syntax, \ie any test normally employed like this:

\begin{ltxcode}
<<\iftest>> true<<\else>> false<<\fi>>
\end{ltxcode}
%
this includes all flags defined with \cmd{newif} as well as \tex primitives such as \cmd{ifmmode}. the \cmd{if} prefix is omitted when using the flag or the primitive in the expression. for example:

\begin{ltxcode}
<<\ifmmode>> true\else false\fi
<<\ifmytest>> true\else false\fi
\end{ltxcode}
%
becomes

\begin{ltxcode}
\ifboolexpr{ <<bool>> {<<mmode>>} }{true}{false}
\ifboolexpr{ <<bool>> {<<mytest>>} }{true}{false}
\end{ltxcode}
%
this also works with flags defined with \cmd{newbool} (see \secref{aut:bo1:bol}). in this case

\begin{ltxcode}
<<\ifbool{mybool}>>{true}{false}
\end{ltxcode}
%
becomes

\begin{ltxcode}
\ifboolexpr{ <<bool>> {<<mybool>>} }{true}{false}
\end{ltxcode}
%
the \texttt{bool} operator may be used with both \cmd{ifboolexpr} and \cmd{ifboolexpe}. 

\item[test]

use the \texttt{test} operator to perform a test based on \latex syntax, \ie any test normally employed like this:

\begin{ltxcode}
<<\iftest>>{<<true>>}{<<false>>}
\end{ltxcode}
%
this applies to all macros based on \latex syntax, \ie the macro must take a \prm{true} and a \prm{false} argument and these must be the final arguments. for example:

\begin{ltxcode}
<<\ifdef>>{\somemacro}<<{true}{false}>>
<<\ifdimless>>{\textwidth}{365pt}<<{true}{false}>>
<<\ifnumcomp>>{\value{somecounter}}{>}{3}<<{true}{false}>>
\end{ltxcode}

when using such tests in the \prm{expression}, their \prm{true} and \prm{false} arguments are omitted. for example:

\begin{ltxcode}
<<\ifcsdef{mymacro}>>{true}{false}
\end{ltxcode}
%
becomes

\begin{ltxcode}
\ifboolexpr{ <<test>> {<<\ifcsdef{mymacro}>>} }{true}{false}
\end{ltxcode}
%
and

\begin{ltxcode}
<<\ifnumcomp{\value{mycounter}}{>}{3}>>{true}{false}
\end{ltxcode}
%
becomes

\begin{ltxcode}
\ifboolexpr{
  <<test>> {<<\ifnumcomp{\value{mycounter}}{>}{3}>>}
}
{true}
{false}
\end{ltxcode}
%
the \texttt{test} operator may be used with \cmd{ifboolexpr} without any restrictions. it may also be used with \cmd{ifboolexpe}, provided that the test is expandable. some of the generic tests in \secref{aut:tst} are robust and may not be used with \cmd{ifboolexpe}, even if \cmd{ifboolexpe} is not located in an expansion-only context. use \cmd{ifboolexpr} instead if the test is not expandable.

\end{marglist}

since \cmd{ifboolexpr} and \cmd{ifboolexpe} imply processing overhead, there is generally no benefit in employing them for a single test. the stand-alone tests in \secref{aut:tst} are more efficient than \texttt{test}, \cmd{ifbool} from \secref{aut:bo1:bol} is more efficient than \texttt{bool}, and \cmd{iftoggle} from \secref{aut:bo1:tgl} is more efficient than \texttt{togl}. the point of \cmd{ifboolexpr} and \cmd{ifboolexpe} is that they support logical operators and subexpressions. the following logical operators are available in the \prm{expression}:

\begin{marglist}
\appto\marglistfont{\verbatimfont}

\item[not]

the \texttt{not} operator negates the truth value of the immediately following element. you may prefix \texttt{togl}, \texttt{bool}, \texttt{test}, and subexpressions with \texttt{not}. for example:

\begin{ltxcode}
\ifboolexpr{
  <<not>> bool {mybool}
}
{true}
{false}
\end{ltxcode}
%
will yield \prm{true} if \texttt{mybool} is false and \prm{false} if \texttt{mybool} is true, and

\begin{ltxcode}
\ifboolexpr{
  <<not (>> bool {boola} or bool {boolb} <<)>>
}
{true}
{false}
\end{ltxcode}
%
will yield \prm{true} if both \texttt{boola} and \texttt{boolb} are false.

\item[and]

the \texttt{and} operator expresses a conjunction (both \emph{a} and \emph{b}). the \prm{expression} is true if all elements joined with \texttt{and} are true. for example:

\begin{ltxcode}
\ifboolexpr{
  bool {boola} <<and>> bool {boolb}
}
{true}
{false}
\end{ltxcode}
%
will yield \prm{true} if both \texttt{bool} tests are true. the \texttt{nand} operator (negated \texttt{and}, \ie not both) is not provided as such but may be expressed by using \texttt{and} in a negated subexpression. for example:

\begin{ltxcode}
bool {boola} <<nand>> bool {boolb}
\end{ltxcode}
%
may be written as

\begin{ltxcode}
<<not>> <<(>> bool {boola} <<and>> bool {boolb} <<)>>
\end{ltxcode}

\item[or]

the \texttt{or} operator expresses a non-exclusive disjunction (either \emph{a} or \emph{b} or both). the \prm{expression} is true if at least one of the elements joined with \texttt{or} is true. for example:

\begin{ltxcode}
\ifboolexpr{
  togl {togla} <<or>> togl {toglb}
}
{true}
{false}
\end{ltxcode}
%
will yield \prm{true} if either \texttt{togl} test or both tests are true. the \texttt{nor} operator (negated non-exclusive disjunction, \ie neither \emph{a} nor \emph{b} nor both) is not provided as such but may be expressed by using \texttt{or} in a negated subexpression. for example:

\begin{ltxcode}
bool {boola} <<nor>> bool {boolb}
\end{ltxcode}
%
may be written as

\begin{ltxcode}
<<not>> <<(>> bool {boola} <<or>> bool {boolb} <<)>>
\end{ltxcode}

\item[(...)]

the parentheses delimit a subexpression in the \prm{expression}. the subexpression is evaluated and the result of this evaluation is treated as a single truth value in the enclosing expression. subexpressions may be nested. for example, the expression:

\begin{ltxcode}
  <<(>> bool {boola} or bool {boolb} <<)>>
  and
  <<(>> bool {boolc} or bool {boold} <<)>>
\end{ltxcode}
%
is true if both subexpressions are true, \ie if at least one of \texttt{boola}/\texttt{boolb} and at least one of \texttt{boolc}/\texttt{boold} is true. subexpressions are generally not required if all elements are joined with \texttt{and} or with \texttt{or}. for example, the expressions

\begin{ltxcode}
bool {boola} <<and>> bool {boolb} <<and>> {boolc} <<and>> bool {boold}
bool {boola} <<or>> bool {boolb} <<or>> {boolc} <<or>> bool {boold}
\end{ltxcode}
%
will yield the expected results: the first one is true if all elements are true; the second one is true if at least one element is true. however, when combining \texttt{and} and \texttt{or}, it is advisable to always group the elements in subexpressions in order to avoid potential misconceptions which may arise from differences between the semantics of formal boolean expressions and the semantics of natural languages. for example, the following expression

\begin{ltxcode}
bool {<<coffee>>} <<and>> bool {<<milk>>} <<or>> bool {<<sugar>>}
\end{ltxcode}
%
is always true if \texttt{sugar} is true since the \texttt{or} operator will take the result of the \texttt{and} evaluation as input. in contrast to the meaning of this expression when pronounced in english, it is not processed like this

\begin{ltxcode}
bool {<<coffee>>} <<and>> <<(>> bool {<<milk>>} <<or>> bool {<<sugar>>} <<)>>
\end{ltxcode}
%
but evaluated strictly from left to right:

\begin{ltxcode}
<<(>> bool {<<coffee>>} <<and>> bool {<<milk>>} <<)>> <<or>> bool {<<sugar>>}
\end{ltxcode}
%
which is probably not what you meant to order.

\end{marglist}

\subsection{list processing}
\label{aut:lst}

\subsubsection{user input}
\label{aut:lst:inp}

the tools in this section are primarily designed to handle user input. when building lists for internal use by a package, using the tools in section \ref{aut:lst:int} may be preferable as they allow testing if an element is in a list.

\begin{ltxsyntax}

\cmditem{declarelistparser}{command}{separator}

this command defines a list parser similar to the \cmd{docsvlist} command below, which is defined like this:

\begin{ltxcode}
\declarelistparser{\docsvlist}{,}
\end{ltxcode}
%
note that the list parsers are sensitive to the category code of the \prm{separator}.

\cmditem*{declarelistparser*}{command}{separator}

the starred variant of \cmd{declarelistparser} defines a list parser similar to the \cmd{forcsvlist} command below, which is defined like this:

\begin{ltxcode}
\declarelistparser*{\forcsvlist}{,}
\end{ltxcode}

\cmditem{docsvlist}{item, item, ...}

this command loops over a comma"=separated list of items and executes the auxiliary command \cmd{do} for every item in the list, passing the item as an argument. in contrast to the \cmd{@for} loop in the \latex kernel, \cmd{docsvlist} is expandable. with a suitable definition of \cmd{do}, lists may be processed in an \cmd{edef} or a comparable context. you may use \cmd{listbreak} at the end of the replacement text of \cmd{do} to stop processing and discard the remaining items in the list. whitespace after list separators is ignored. if an item contains a comma or starts with a space, it must be wrapped in curly braces. the braces will be removed as the list is processed. here is a usage example which prints a comma"=separated list as an \env{itemize} environment:

\begin{ltxcode}
\begin{itemize}
\renewcommand*{\do}[1]{\item #1}
\docsvlist{item1, item2, {item3a, item3b}, item4}
\end{itemize}
\end{ltxcode}
%
here is another example:

\begin{ltxcode}
\renewcommand*{\do}[1]{* #1\messagebreak}
\packageinfo{mypackage}{%
  example list:\messagebreak
  \docsvlist{item1, item2, {item3a, item3b}, item4}}
\end{ltxcode}
%
in this example, the list is written to the log file as part of an informational message. the list processing takes place during the \cmd{write} operation.

\cmditem{forcsvlist}{handler}{item, item, ...}

this command is similar to \cmd{docsvlist} except that \cmd{do} is replaced by a \prm{handler} specified at invocation time. the \prm{handler} may also be a sequence of commands, provided that the command given last takes the item as trailing argument. for example, the following code will convert a comma"=separated list of items into an internal list called \cmd{mylist}:

\begin{ltxcode}
\forcsvlist{\listadd\mylist}{item1, item2, item3}
\end{ltxcode}

\end{ltxsyntax}

\subsubsection{internal lists}
\label{aut:lst:int}

the tools in this section handle internal lists of data. an <internal list> in this context is a plain macro without any parameters and prefixes which is employed to collect data. these lists use a special character as internal list separator.\footnote{the character \texttt{\string|} with category code 3. note that you may not typeset a list by saying \cmd{listname}. use \cmd{show} instead to inspect the list.} when processing user input in list format, see the tools in section \ref{aut:lst:inp}.

\begin{ltxsyntax}

\cmditem{listadd}{listmacro}{item}

this command appends an \prm{item} to a \prm{listmacro}. a blank \prm{item} is not added to the list.

\cmditem{listgadd}{listmacro}{item}

similar to \cmd{listadd} except that the assignment is global.

\cmditem{listeadd}{listmacro}{item}

similar to \cmd{listadd} except that the \prm{item} is expanded at definition"=time. only the new \prm{item} is expanded, the \prm{listmacro} is not. if the expanded \prm{item} is blank, it is not added to the list.

\cmditem{listxadd}{listmacro}{item}

similar to \cmd{listeadd} except that the assignment is global.

\cmditem{listcsadd}{listcsname}{item}

similar to \cmd{listadd} except that it takes a control sequence name as its first argument.

\cmditem{listcsgadd}{listcsname}{item}

similar to \cmd{listcsadd} except that the assignment is global.

\cmditem{listcseadd}{listcsname}{item}

similar to \cmd{listeadd} except that it takes a control sequence name as its first argument.

\cmditem{listcsxadd}{listcsname}{item}

similar to \cmd{listcseadd} except that the assignment is global.

\cmditem{listremove}{listmacro}{item}

this command removes an \prm{item} from a \prm{listmacro}. a blank \prm{item} is ignored.

\cmditem{listgremove}{listmacro}{item}

similar to \cmd{listremove} except that the assignment is global.

\cmditem{listcsremove}{listcsname}{item}

similar to \cmd{listremove} except that it takes a control sequence name as its first argument.

\cmditem{listcsgremove}{listcsname}{item}

similar to \cmd{listcsremove} except that the assignment is global.

\cmditem{dolistloop}{listmacro}

this command loops over all items in a \prm{listmacro} and executes the auxiliary command \cmd{do} for every item in the list, passing the item as an argument. the list loop itself is expandable. you may use \cmd{listbreak} at the end of the replacement text of \cmd{do} to stop processing and discard the remaining items in the list. here is a usage example which prints an internal list called \cmd{mylist} as an \env{itemize} environment:

\begin{ltxcode}
\begin{itemize}
\renewcommand*{\do}[1]{\item #1}
\dolistloop{\mylist}
\end{itemize}
\end{ltxcode}

\cmditem{dolistcsloop}{listcsname}

similar to \cmd{dolistloop} except that it takes a control sequence name as its argument.

\cmditem{forlistloop}{handler}{listmacro}

this command is similar to \cmd{dolistloop} except that \cmd{do} is replaced by a \prm{handler} specified at invocation time. the \prm{handler} may also be a sequence of commands, provided that the command given last takes the item as trailing argument. for example, the following code will prefix all items in the internal list \cmd{mylist} with \cmd{item}, count the items as the list is processed, and append the item count at the end:

\begin{ltxcode}
\newcounter{itemcount}
\begin{itemize}
\forlistloop{\stepcounter{itemcount}\item}{\mylist}
\item total: \number\value{itemcount} items
\end{itemize}
\end{ltxcode}

\cmditem{forlistcsloop}{handler}{listcsname}

similar to \cmd{forlistloop} except that it takes a control sequence name as its second argument.

\cmditem{ifinlist}{item}{listmacro}{true}{false}

this command executes \prm{true} if the \prm{item} is included in a \prm{listmacro}, and \prm{false} otherwise. note that this test uses pattern matching based on \tex's argument scanner to check if the search string is included in the list. this means that it is usually faster than looping over all items in the list, but it also implies that the items must not include curly braces which would effectively hide them from the scanner. in other words, this macro is most useful when dealing with lists of plain strings rather than printable data. when dealing with printable text, it is safer to use \cmd{dolistloop} to check if an item is in the list as follows:

\begin{ltxcode}
\renewcommand*{\do}[1]{%
  \ifstrequal{#1}{<<item>>}
    {item found!\listbreak}
    {}}
\dolistloop{\mylist}
\end{ltxcode}

\cmditem{xifinlist}{item}{listmacro}{true}{false}

similar to \cmd{ifinlist} except that the \prm{item} is expanded prior to the test.

\cmditem{ifinlistcs}{item}{listcsname}{true}{false}

similar to \cmd{ifinlist} except that it takes a control sequence name as its second argument.

\cmditem{xifinlistcs}{item}{listcsname}{true}{false}

similar to \cmd{xifinlist} except that it takes a control sequence name as its second argument.

\end{ltxsyntax}

\subsection{miscellaneous tools}
\label{aut:msc}

\begin{ltxsyntax}

\cmditem{rmntonum}{numeral}

the \tex primitive \cmd{romannumeral} converts an integer to a roman numeral but \tex or \latex provide no command which goes the opposite way. \cmd{rmntonum} fills this gap. it takes a roman numeral as its argument and converts it to the corresponding integer. since it is expandable, it may also be used in counter assignments or arithmetic tests:

\begin{ltxcode}
<<\rmntonum>>{<<mcmxcv>>}
\setcounter{counter}{<<\rmntonum>>{<<cxvi>>}}
\ifnumless{<<\rmntonum>>{<<mcmxcviii>>}}{2000}{true}{false}
\end{ltxcode}
%
the \prm{numeral} argument must be a literal string. it will be detokenized prior to parsing. the parsing of the numeral is case"=insensitive and whitespace in the argument is ignored. if there is an invalid token in the argument, \cmd{rmntonum} will expand to~\texttt{-1}; an empty argument will yield an empty string. note that \cmd{rmntonum} will not check the numeral for formal validity. for example, both \texttt{v} and \texttt{vx} would yield \texttt{5}, \texttt{ic} would yield \texttt{99}, etc.

\cmditem{ifrmnum}{string}{true}{false}

expands to \prm{true} if \prm{string} is a roman numeral, and to \prm{false} otherwise. the \prm{string} will be detokenized prior to performing the test. the test is case"=insensitive and ignores whitespace in the \prm{string}. note that \cmd{ifrmnum} will not check the numeral for formal validity. for example, both \texttt{v} and \texttt{vxv} will yield \prm{true}. strictly speaking, what \cmd{ifrmnum} does is parse the \prm{string} in order to find out if it consists of characters which may form a valid roman numeral, but it will not check if they really are a valid roman numeral.

\end{ltxsyntax}

\section{reporting issues}

the development code for \sty{etoolbox} is hosted on github: \url{https://github.com/josephwright/etoolbox}. this is the best place to log any issues with the package.

\section{revision history}

this revision history is a list of changes relevant to users of this package. changes of a more technical nature which do not affect the user interface or the behavior of the package are not included in the list. if an entry in the revision history states that a feature has been \emph{improved} or \emph{extended}, this indicates a syntactically backwards compatible modification, such as the addition of an optional argument to an existing command. entries stating that a feature has been \emph{modified} demand attention. they indicate a modification which may require changes to existing documents in some, hopefully rare, cases. the numbers on the right indicate the relevant section of this manual.

\begin{changelog}

\begin{release}{2.5j}{2020-08-24}
\item track \latexe{} kernel changes
\end{release}

\begin{release}{2.5i}{2020-07-13}
\item track \latexe{} kernel changes
\end{release}

\begin{release}{2.5h}{2019-09-21}
\item add missing \cmd{gundef}
\end{release}

\begin{release}{2.5g}{2019-09-09}
\item update patching of \cmd{begin} and \cmd{end} in advance of \latex{}
  kernel changes
\end{release}

\begin{release}{2.5f}{2018-08-18}
\item fix issue with \cmd{ifdefempty}, \cmd{ifcsempty}, \cs{ifdefvoid}
  and \cmd{ifcsvoid} when applied to macros expanding to space tokens
\end{release}

\begin{release}{2.5e}{2018-02-11}
\item more work on empty list separator in \cmd{declarelistparser}
\end{release}

\begin{release}{2.5d}{2018-02-10}
\item allow for empty list separator in \cmd{declarelistparser}
\end{release}

\begin{release}{2.5c}{2018-02-06}
\item fix issue with \cmd{forcsvlist} introduced by v2.5b
\end{release}

\begin{release}{2.5b}{2018-02-04}
\item preserve braces in some internal steps
\item internal performance improvements in list processors
\end{release}

\begin{release}{2.5a}{2018-02-03}
\item internal performance improvements in list processors
\end{release}

\begin{release}{2.5}{2017-11-22}
\item added \cmd{csgundef}\see{aut:def:def}
\item added \cmd{gundef}\see{aut:def:def}
\item allow scanning of macros containing new line characters
\end{release}

\begin{release}{2.4}{2017-01-02}
\item renamed \cmd{listdel} to \cmd{listremove} (name clash)\see{aut:lst:int}
\item renamed \cmd{listgdel} to \cmd{listgremove} (name clash)\see{aut:lst:int}
\end{release}

\begin{release}{2.3}{2016-12-26}
\item added \cmd{listdel}\see{aut:lst:int}
\item added \cmd{listgdel}\see{aut:lst:int}
\end{release}

\begin{release}{2.2b}{2016-12-01}
\item fixed \cmd{ifdefltxprotect} for some types of \latex robust commands
\item remove redundant macro after \cmd{robustify} processing
\end{release}

\begin{release}{2.2a}{2015-08-02}
\item fixed robustness bug in \cmd{ifblank}/\cmd{notblank}
\end{release}

\begin{release}{2.2}{2015-05-04}
\item added \cmd{csmeaning}\see{aut:def:def}
\end{release}

\begin{release}{2.1d}{2015-03-19}
\item fixed issue with \sty{bm} and some classes
\end{release}

\begin{release}{2.1c}{2015-03-15}
\item fixed space bug in \cmd{ifpatchable}
\item fixed space bug in \cmd{patchcmd}
\item fixed space bug in \cmd{robustify}
\end{release}

\begin{release}{2.1b}{2015-03-10}
\item minor documentation fixes
\end{release}

\begin{release}{2.1a}{2015-03-10}
\item new maintainer: joseph  wright
\item skip loading \sty{etex} package with newer \latex kernel releases
\end{release}

\begin{release}{2.1}{2011-01-03}
\item added \cmd{atbeginenvironment}\see{use:env}
\item added \cmd{atendenvironment}\see{use:env}
\item added \cmd{beforebeginenvironment}\see{use:env}
\item added \cmd{afterendenvironment}\see{use:env}
\item added \cmd{ifdefstrequal}\see{aut:tst:def}
\item added \cmd{ifcsstrequal}\see{aut:tst:def}
\item added \cmd{ifdefcounter}\see{aut:tst:cnt}
\item added \cmd{ifcscounter}\see{aut:tst:cnt}
\item added \cmd{ifltxcounter}\see{aut:tst:cnt}
\item added \cmd{ifdeflength}\see{aut:tst:cnt}
\item added \cmd{ifcslength}\see{aut:tst:cnt}
\item added \cmd{ifdefdimen}\see{aut:tst:cnt}
\item added \cmd{ifcsdimen}\see{aut:tst:cnt}
\end{release}

\begin{release}{2.0a}{2010-09-12}
\item fixed bug in \cmd{patchcmd}, \cmd{apptocmd}, \cmd{pretocmd}\see{aut:pat}
\end{release}

\begin{release}{2.0}{2010-08-21}

\item added \cmd{csshow}\see{aut:def:def}
\item added \cmd{declarelistparser*}\see{aut:lst:inp}
\item added \cmd{forcsvlist}\see{aut:lst:inp}
\item added \cmd{forlistloop}\see{aut:lst:int}
\item added \cmd{forlistcsloop}\see{aut:lst:int}
\item allow testing \cmd{par} in macro tests\see{aut:tst:def}
\item fixed some bugs

\end{release}

\begin{release}{1.9}{2010-04-10}

\item improved \cmd{letcs}\see{aut:def:def}
\item improved \cmd{csletcs}\see{aut:def:def}
\item improved \cmd{listeadd}\see{aut:lst:int}
\item improved \cmd{listxadd}\see{aut:lst:int}
\item added \cmd{notblank}\see{aut:tst:str}
\item added \cmd{ifnumodd}\see{aut:tst:num}
\item added \cmd{ifboolexpr}\see{aut:tst:bol}
\item added \cmd{ifboolexpe}\see{aut:tst:bol}
\item added \cmd{whileboolexpr}\see{aut:tst:bol}
\item added \cmd{unlessboolexpr}\see{aut:tst:bol}

\end{release}

\begin{release}{1.8}{2009-08-06}

\item improved \cmd{deflength}\see{use:cal}
\item added \cmd{ifnumcomp}\see{aut:tst:num}
\item added \cmd{ifnumequal}\see{aut:tst:num}
\item added \cmd{ifnumgreater}\see{aut:tst:num}
\item added \cmd{ifnumless}\see{aut:tst:num}
\item added \cmd{ifdimcomp}\see{aut:tst:num}
\item added \cmd{ifdimequal}\see{aut:tst:num}
\item added \cmd{ifdimgreater}\see{aut:tst:num}
\item added \cmd{ifdimless}\see{aut:tst:num}

\end{release}

\begin{release}{1.7}{2008-06-28}

\item renamed \cmd{afterbegindocument} to \cmd{afterendpreamble} (name clash)\see{use:pre}
\item resolved conflict with \sty{hyperref}
\item rearranged manual slightly 

\end{release}

\begin{release}{1.6}{2008-06-22}

\item improved \cmd{robustify}\see{use:pat}
\item improved \cmd{patchcmd} and \cmd{ifpatchable}\see{aut:pat}
\item modified and improved \cmd{apptocmd}\see{aut:pat}
\item modified and improved \cmd{pretocmd}\see{aut:pat}
\item added \cmd{ifpatchable*}\see{aut:pat}
\item added \cmd{tracingpatches}\see{aut:pat}
\item added \cmd{afterbegindocument}\see{use:pre}
\item added \cmd{ifdefmacro}\see{aut:tst:def}
\item added \cmd{ifcsmacro}\see{aut:tst:def}
\item added \cmd{ifdefprefix}\see{aut:tst:def}
\item added \cmd{ifcsprefix}\see{aut:tst:def}
\item added \cmd{ifdefparam}\see{aut:tst:def}
\item added \cmd{ifcsparam}\see{aut:tst:def}
\item added \cmd{ifdefprotected}\see{aut:tst:def}
\item added \cmd{ifcsprotected}\see{aut:tst:def}
\item added \cmd{ifdefltxprotect}\see{aut:tst:def}
\item added \cmd{ifcsltxprotect}\see{aut:tst:def}
\item added \cmd{ifdefempty}\see{aut:tst:def}
\item added \cmd{ifcsempty}\see{aut:tst:def}
\item improved \cmd{ifdefvoid}\see{aut:tst:def}
\item improved \cmd{ifcsvoid}\see{aut:tst:def}
\item added \cmd{ifstrempty}\see{aut:tst:str}
\item added \cmd{setbool}\see{aut:bo1:bol}
\item added \cmd{settoggle}\see{aut:bo1:tgl}

\end{release}

\begin{release}{1.5}{2008-04-26}

\item added \cmd{defcounter}\see{use:cal}
\item added \cmd{deflength}\see{use:cal}
\item added \cmd{ifdefstring}\see{aut:tst:def}
\item added \cmd{ifcsstring}\see{aut:tst:def}
\item improved \cmd{rmntonum}\see{aut:msc}
\item added \cmd{ifrmnum}\see{aut:msc}
\item added extended \pdf bookmarks to this manual
\item rearranged manual slightly 

\end{release}

\begin{release}{1.4}{2008-01-24}

\item resolved conflict with \sty{tex4ht}

\end{release}

\begin{release}{1.3}{2007-10-08}

\item renamed package from \sty{elatex} to \sty{etoolbox}\see{int}
\item renamed \cmd{newswitch} to \cmd{newtoggle} (name clash)\see{aut:bo1:tgl}
\item renamed \cmd{provideswitch} to \cmd{providetoggle} (consistency)\see{aut:bo1:tgl}
\item renamed \cmd{switchtrue} to \cmd{toggletrue} (consistency)\see{aut:bo1:tgl}
\item renamed \cmd{switchfalse} to \cmd{togglefalse} (consistency)\see{aut:bo1:tgl}
\item renamed \cmd{ifswitch} to \cmd{iftoggle} (consistency)\see{aut:bo1:tgl}
\item renamed \cmd{notswitch} to \cmd{nottoggle} (consistency)\see{aut:bo1:tgl}
\item added \cmd{atendpreamble}\see{use:pre}
\item added \cmd{afterenddocument}\see{use:pre}
\item added \cmd{afterpreamble}\see{use:pre}
\item added \cmd{undef}\see{aut:def:def}
\item added \cmd{csundef}\see{aut:def:def}
\item added \cmd{ifdefvoid}\see{aut:tst:def}
\item added \cmd{ifcsvoid}\see{aut:tst:def}
\item added \cmd{ifdefequal}\see{aut:tst:def}
\item added \cmd{ifcsequal}\see{aut:tst:def}
\item added \cmd{ifstrequal}\see{aut:tst:str}
\item added \cmd{listadd}\see{aut:lst:int}
\item added \cmd{listeadd}\see{aut:lst:int}
\item added \cmd{listgadd}\see{aut:lst:int}
\item added \cmd{listxadd}\see{aut:lst:int}
\item added \cmd{listcsadd}\see{aut:lst:int}
\item added \cmd{listcseadd}\see{aut:lst:int}
\item added \cmd{listcsgadd}\see{aut:lst:int}
\item added \cmd{listcsxadd}\see{aut:lst:int}
\item added \cmd{ifinlist}\see{aut:lst:int}
\item added \cmd{xifinlist}\see{aut:lst:int}
\item added \cmd{ifinlistcs}\see{aut:lst:int}
\item added \cmd{xifinlistcs}\see{aut:lst:int}
\item added \cmd{dolistloop}\see{aut:lst:int}
\item added \cmd{dolistcsloop}\see{aut:lst:int}

\end{release}

\begin{release}{1.2}{2007-07-13}

\item renamed \cmd{patchcommand} to \cmd{patchcmd} (name clash)\see{aut:pat}
\item renamed \cmd{apptocommand} to \cmd{apptocmd} (consistency)\see{aut:pat}
\item renamed \cmd{pretocommand} to \cmd{pretocmd} (consistency)\see{aut:pat}
\item added \cmd{newbool}\see{aut:bo1:bol}
\item added \cmd{providebool}\see{aut:bo1:bol}
\item added \cmd{booltrue}\see{aut:bo1:bol}
\item added \cmd{boolfalse}\see{aut:bo1:bol}
\item added \cmd{ifbool}\see{aut:bo1:bol}
\item added \cmd{notbool}\see{aut:bo1:bol}
\item added \cmd{newswitch}\see{aut:bo1:tgl}
\item added \cmd{provideswitch}\see{aut:bo1:tgl}
\item added \cmd{switchtrue}\see{aut:bo1:tgl}
\item added \cmd{switchfalse}\see{aut:bo1:tgl}
\item added \cmd{ifswitch}\see{aut:bo1:tgl}
\item added \cmd{notswitch}\see{aut:bo1:tgl}
\item added \cmd{declarelistparser}\see{aut:lst:inp}
\item added \cmd{docsvlist}\see{aut:lst:inp}
\item added \cmd{rmntonum}\see{aut:msc}

\end{release}

\begin{release}{1.1}{2007-05-28}

\item added \cmd{protected@csedef}\see{aut:def:def}
\item added \cmd{protected@csxdef}\see{aut:def:def}
\item added \cmd{gluedef}\see{aut:def:cal}
\item added \cmd{gluegdef}\see{aut:def:cal}
\item added \cmd{csgluedef}\see{aut:def:cal}
\item added \cmd{csgluegdef}\see{aut:def:cal}
\item added \cmd{mudef}\see{aut:def:cal}
\item added \cmd{mugdef}\see{aut:def:cal}
\item added \cmd{csmudef}\see{aut:def:cal}
\item added \cmd{csmugdef}\see{aut:def:cal}
\item added \cmd{protected@eappto}\see{aut:hok:app}
\item added \cmd{protected@xappto}\see{aut:hok:app}
\item added \cmd{protected@cseappto}\see{aut:hok:app}
\item added \cmd{protected@csxappto}\see{aut:hok:app}
\item added \cmd{protected@epreto}\see{aut:hok:pre}
\item added \cmd{protected@xpreto}\see{aut:hok:pre}
\item added \cmd{protected@csepreto}\see{aut:hok:pre}
\item added \cmd{protected@csxpreto}\see{aut:hok:pre}
\item fixed bug in \cmd{newrobustcmd}\see{use:def}
\item fixed bug in \cmd{renewrobustcmd}\see{use:def}
\item fixed bug in \cmd{providerobustcmd}\see{use:def}

\end{release}

\begin{release}{1.0}{2007-05-07}

\item initial public release

\end{release}

\end{changelog}

\end{document}
